{"version":3,"file":"scrolltohighlight.min.js","sources":["../src/scrolltohighlight.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Scroll to highlighted text in course modules\n *\n * @module     mod_coursesearch/scrolltohighlight\n * @copyright  2025\n * @license    http://www.gnu.org/licenses/gpl-3.0.html GNU GPL v3 or later\n */\n\n/* eslint-disable max-depth */\n/* eslint-disable complexity */\n/* eslint-disable promise/catch-or-return */\n/* eslint-disable promise/always-return */\n\ndefine(['jquery'], function($) {\n    'use strict';\n\n    // Flag to prevent multiple executions.\n    let hasHighlighted = false;\n\n    /**\n     * Expand Bootstrap accordion/collapse if text is found inside a collapsed section\n     * Returns a promise that resolves when accordion is expanded (or immediately if not needed)\n     * @param {string} searchText The search text to look for\n     * @return {Promise} Promise that resolves when accordion is expanded\n     */\n    function expandAccordionIfNeeded(searchText) {\n        return new Promise(function(resolve) {\n            const searchLower = searchText.toLowerCase();\n\n            // Find all collapsed sections (Bootstrap 4 uses .collapse:not(.show)).\n            const collapsedSections = document.querySelectorAll('.collapse:not(.show)');\n\n            let foundInCollapsed = null;\n            let triggerButton = null;\n\n            // Check each collapsed section for the search text.\n            for (let i = 0; i < collapsedSections.length; i++) {\n                const section = collapsedSections[i];\n                const textContent = section.textContent.toLowerCase();\n\n                if (textContent.indexOf(searchLower) !== -1) {\n                    foundInCollapsed = section;\n\n                    // Find the trigger button for this collapse.\n                    // It could be a button with data-target=\"#id\" or data-bs-target=\"#id\".\n                    const sectionId = section.id;\n                    if (sectionId) {\n                        triggerButton = document.querySelector('[data-target=\"#' + sectionId + '\"]') ||\n                                       document.querySelector('[data-bs-target=\"#' + sectionId + '\"]') ||\n                                       document.querySelector('[href=\"#' + sectionId + '\"]');\n                    }\n\n                    // Also check aria-controls.\n                    if (!triggerButton && sectionId) {\n                        triggerButton = document.querySelector('[aria-controls=\"' + sectionId + '\"]');\n                    }\n\n                    break;\n                }\n            }\n\n            if (foundInCollapsed && triggerButton) {\n                // Listen for the collapse to finish expanding.\n                $(foundInCollapsed).one('shown.bs.collapse', function() {\n                    // Small delay to ensure DOM is updated.\n                    setTimeout(resolve, 100);\n                });\n\n                // Click the trigger to expand.\n                triggerButton.click();\n\n                // Fallback timeout in case the event doesn't fire.\n                setTimeout(function() {\n                    resolve();\n                }, 1000);\n            } else if (foundInCollapsed) {\n                // No trigger found, try to expand using Bootstrap's collapse API directly.\n                $(foundInCollapsed).collapse('show');\n\n                $(foundInCollapsed).one('shown.bs.collapse', function() {\n                    setTimeout(resolve, 100);\n                });\n\n                // Fallback timeout.\n                setTimeout(function() {\n                    resolve();\n                }, 1000);\n            } else {\n                // Text not in collapsed section, resolve immediately.\n                resolve();\n            }\n        });\n    }\n\n    /**\n     * Check if element is hidden\n     * @param {HTMLElement} el Element to check\n     * @param {HTMLElement} boundary Boundary element\n     * @return {boolean} True if hidden\n     */\n    function isElementHidden(el, boundary) {\n        let parent = el;\n        while (parent && parent !== boundary) {\n            const classList = parent.classList;\n            const style = window.getComputedStyle(parent);\n            // Skip screen-reader only elements and hidden elements.\n            if (classList.contains('sr-only') ||\n                classList.contains('visually-hidden') ||\n                classList.contains('hidden') ||\n                style.display === 'none' ||\n                style.visibility === 'hidden' ||\n                (style.position === 'absolute' && style.clip === 'rect(0px, 0px, 0px, 0px)')) {\n                return true;\n            }\n            parent = parent.parentElement;\n        }\n        return false;\n    }\n\n    /**\n     * Get all visible text nodes within element\n     * @param {HTMLElement} element Element to search\n     * @return {Array} Array of text nodes\n     */\n    function getVisibleTextNodes(element) {\n        const walker = document.createTreeWalker(\n            element,\n            NodeFilter.SHOW_TEXT,\n            {\n                acceptNode: function(node) {\n                    // Skip empty text nodes.\n                    if (!node.textContent.trim()) {\n                        return NodeFilter.FILTER_REJECT;\n                    }\n                    // Skip nodes inside hidden elements.\n                    if (isElementHidden(node.parentElement, element)) {\n                        return NodeFilter.FILTER_REJECT;\n                    }\n                    return NodeFilter.FILTER_ACCEPT;\n                }\n            },\n            false\n        );\n\n        let node;\n        const textNodes = [];\n        while ((node = walker.nextNode()) !== null) {\n            textNodes.push(node);\n        }\n        return textNodes;\n    }\n\n    /**\n     * Apply temporary highlight to element\n     * @param {HTMLElement} el Element to highlight\n     */\n    function applyHighlight(el) {\n        const originalBg = el.style.backgroundColor;\n        el.style.setProperty('background-color', '#ffff99', 'important');\n        setTimeout(function() {\n            if (originalBg) {\n                el.style.setProperty('background-color', originalBg);\n            } else {\n                el.style.removeProperty('background-color');\n            }\n        }, 3000);\n    }\n\n    /**\n     * Find suitable parent element for highlighting\n     * @param {Node} node Starting node\n     * @param {HTMLElement} boundary Boundary element\n     * @param {Array} validTags Valid tag names\n     * @return {HTMLElement|null} Parent element or null\n     */\n    function findHighlightParent(node, boundary, validTags) {\n        let parent = node.parentElement;\n        while (parent && parent !== boundary && parent !== document.body) {\n            const tagName = parent.tagName.toUpperCase();\n            if (validTags.includes(tagName)) {\n                break;\n            }\n            parent = parent.parentElement;\n        }\n        if (parent && parent !== boundary && parent !== document.body && parent !== document.documentElement) {\n            return parent;\n        }\n        return null;\n    }\n\n    /**\n     * Find text within an element and scroll to it\n     * @param {HTMLElement} element The element to search within\n     * @param {string} searchText The text to search for\n     * @return {boolean} True if text was found and scrolled to\n     */\n    function scrollToText(element, searchText) {\n        if (!element || !searchText) {\n            return false;\n        }\n\n        const textNodes = getVisibleTextNodes(element);\n        const searchLower = searchText.toLowerCase();\n        const normalizedSearch = searchLower.replace(/[\\u00A0\\s]+/g, ' ');\n\n        // Build combined text from all nodes.\n        let combinedText = '';\n        for (let i = 0; i < textNodes.length; i++) {\n            combinedText += textNodes[i].textContent;\n        }\n        const normalizedCombined = combinedText.replace(/[\\u00A0\\s]+/g, ' ').toLowerCase();\n        const combinedIndex = normalizedCombined.indexOf(normalizedSearch);\n\n        if (combinedIndex !== -1) {\n            let foundNodeIndex = -1;\n\n            // First, try to find exact match in a single text node.\n            for (let i = 0; i < textNodes.length; i++) {\n                const nodeText = textNodes[i].textContent;\n                const nodeTextLower = nodeText.replace(/[\\u00A0\\s]+/g, ' ').toLowerCase();\n                if (nodeTextLower.indexOf(normalizedSearch) !== -1) {\n                    foundNodeIndex = i;\n                    break;\n                }\n            }\n\n            // If no exact match in single node, find the node that contains the START of the match.\n            if (foundNodeIndex === -1) {\n                const firstWord = normalizedSearch.split(' ')[0];\n                let charCount = 0;\n                const nodePositions = [];\n                for (let i = 0; i < textNodes.length; i++) {\n                    const nodeText = textNodes[i].textContent;\n                    const normalizedNode = nodeText.replace(/[\\u00A0\\s]+/g, ' ').toLowerCase();\n                    nodePositions.push({\n                        nodeIndex: i,\n                        start: charCount,\n                        end: charCount + normalizedNode.length,\n                        text: normalizedNode\n                    });\n                    charCount += normalizedNode.length;\n                }\n\n                // Try to find a node containing the first word at the right position.\n                for (let i = 0; i < nodePositions.length; i++) {\n                    const np = nodePositions[i];\n                    if (np.end > combinedIndex && np.start <= combinedIndex + normalizedSearch.length) {\n                        if (np.text.indexOf(firstWord) !== -1) {\n                            foundNodeIndex = i;\n                            break;\n                        }\n                    }\n                }\n\n                // Fallback: find which node contains position combinedIndex.\n                if (foundNodeIndex === -1) {\n                    for (let i = 0; i < nodePositions.length; i++) {\n                        if (combinedIndex >= nodePositions[i].start && combinedIndex < nodePositions[i].end) {\n                            foundNodeIndex = i;\n                            break;\n                        }\n                    }\n                }\n            }\n\n            if (foundNodeIndex !== -1) {\n                const blockTags = ['P', 'DIV', 'LI', 'TD', 'TH', 'BLOCKQUOTE', 'ARTICLE', 'SECTION'];\n                const parent = findHighlightParent(textNodes[foundNodeIndex], element, blockTags);\n                if (parent) {\n                    const rect = parent.getBoundingClientRect();\n                    const scrollY = window.scrollY + rect.top - 100;\n                    window.scrollTo({top: scrollY, behavior: 'smooth'});\n                    applyHighlight(parent);\n                    return true;\n                }\n            }\n        }\n\n        // Original single-node search.\n        for (let i = 0; i < textNodes.length; i++) {\n            const text = textNodes[i].textContent.toLowerCase();\n            const index = text.indexOf(searchLower);\n            if (index !== -1) {\n                const range = document.createRange();\n                const textNode = textNodes[i];\n                const originalText = textNode.textContent;\n                const originalIndex = originalText.toLowerCase().indexOf(searchLower);\n\n                if (originalIndex !== -1) {\n                    try {\n                        range.setStart(textNode, originalIndex);\n                        range.setEnd(textNode, originalIndex + searchText.length);\n                        const rect = range.getBoundingClientRect();\n                        const scrollY = window.scrollY + rect.top - 100;\n                        window.scrollTo({top: scrollY, behavior: 'smooth'});\n\n                        // Highlight the text temporarily.\n                        const span = document.createElement('span');\n                        span.style.setProperty('background-color', '#ffff99', 'important');\n                        span.style.setProperty('padding', '2px', 'important');\n                        span.style.setProperty('border-radius', '2px', 'important');\n                        span.style.setProperty('color', 'inherit', 'important');\n                        span.style.setProperty('display', 'inline', 'important');\n                        span.className = 'coursesearch-highlight-temp';\n\n                        let highlighted = false;\n                        try {\n                            const canSurround = range.startContainer === range.endContainer ||\n                                (range.startContainer.nodeType === Node.TEXT_NODE &&\n                                 range.endContainer.nodeType === Node.TEXT_NODE);\n\n                            if (canSurround) {\n                                range.surroundContents(span);\n                                highlighted = true;\n                                setTimeout(function() {\n                                    if (span.parentNode) {\n                                        const spanParent = span.parentNode;\n                                        spanParent.replaceChild(document.createTextNode(span.textContent), span);\n                                        spanParent.normalize();\n                                    }\n                                }, 3000);\n                            }\n                        } catch (e) {\n                            highlighted = false;\n                        }\n\n                        // Fallback: highlight the parent element if direct highlighting failed.\n                        if (!highlighted) {\n                            const inlineTags = ['P', 'DIV', 'SPAN', 'A', 'LI', 'TD', 'TH', 'LABEL',\n                                     'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'STRONG', 'EM', 'B', 'I', 'U'];\n                            const parent = findHighlightParent(textNode, element, inlineTags);\n                            if (parent) {\n                                applyHighlight(parent);\n                            }\n                        }\n\n                        return true;\n                    } catch (e) {\n                        // If range operations fail, just scroll to the element.\n                        const elementTop = element.getBoundingClientRect().top + window.scrollY;\n                        window.scrollTo({top: elementTop - 100, behavior: 'smooth'});\n                        return true;\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Initialize scrolling to highlighted text\n     */\n    function init() {\n        // Prevent multiple executions.\n        if (hasHighlighted) {\n            return;\n        }\n\n        // Check for highlight parameter in URL.\n        const urlParams = new URLSearchParams(window.location.search);\n        let highlightText = urlParams.get('highlight');\n\n        // If not in URL, check sessionStorage (set by coursesearch module).\n        let storedModuleId = null;\n        if (!highlightText && typeof sessionStorage !== 'undefined') {\n            const storedHighlight = sessionStorage.getItem('coursesearch_highlight');\n            storedModuleId = sessionStorage.getItem('coursesearch_moduleId');\n            const timestamp = sessionStorage.getItem('coursesearch_timestamp');\n\n            // Check if timestamp is recent (within 10 seconds).\n            if (timestamp && Date.now() - parseInt(timestamp, 10) > 10000) {\n                // Data is too old, clear it.\n                sessionStorage.removeItem('coursesearch_highlight');\n                sessionStorage.removeItem('coursesearch_moduleId');\n                sessionStorage.removeItem('coursesearch_timestamp');\n                sessionStorage.removeItem('coursesearch_shouldScroll');\n                return;\n            }\n\n            if (storedHighlight) {\n                // The value was stored using JSON.stringify, so parse it back safely.\n                try {\n                    highlightText = JSON.parse(storedHighlight);\n                    if (typeof highlightText !== 'string') {\n                        highlightText = null;\n                    }\n                } catch (e) {\n                    // If JSON parsing fails, try using it directly (backwards compatibility).\n                    highlightText = storedHighlight;\n                }\n                // Clear it after use.\n                sessionStorage.removeItem('coursesearch_highlight');\n                sessionStorage.removeItem('coursesearch_moduleId');\n                sessionStorage.removeItem('coursesearch_timestamp');\n                sessionStorage.removeItem('coursesearch_shouldScroll');\n            }\n        }\n\n        if (!highlightText) {\n            return;\n        }\n\n        // Mark as highlighted to prevent re-runs.\n        hasHighlighted = true;\n\n        // Decode the text.\n        const searchText = decodeURIComponent(highlightText).trim();\n        if (!searchText) {\n            return;\n        }\n\n        // Wait for page to be fully loaded.\n        $(document).ready(function() {\n            // Small delay to ensure all content is rendered.\n            setTimeout(function() {\n                // First, expand any accordion that contains the search text.\n                expandAccordionIfNeeded(searchText).then(function() {\n                    // Check if we have a moduleId from sessionStorage first, then URL hash.\n                    let moduleId = storedModuleId;\n                    const hash = window.location.hash;\n\n                    if (!moduleId && hash) {\n                        // Extract module ID from hash (format: #module-123).\n                        const match = hash.match(/^#module-(\\d+)$/);\n                        if (match) {\n                            moduleId = match[1];\n                        }\n                    }\n\n                    // Validate moduleId is numeric only.\n                    if (moduleId && !/^\\d+$/.test(moduleId)) {\n                        moduleId = null;\n                    }\n\n                    if (moduleId) {\n                        const moduleElement = document.getElementById('module-' + moduleId);\n\n                        if (moduleElement) {\n                            // Try to find and scroll to the text within this module.\n                            if (!scrollToText(moduleElement, searchText)) {\n                                // If text not found in module, try searching in whole page.\n                                if (!scrollToText(document.body, searchText)) {\n                                    // If still not found, just scroll to the module.\n                                    const elementTop = moduleElement.getBoundingClientRect().top + window.scrollY;\n                                    window.scrollTo({top: elementTop - 100, behavior: 'smooth'});\n                                }\n                            }\n                        } else {\n                            // Module element not found, search in whole page.\n                            scrollToText(document.body, searchText);\n                        }\n                    } else {\n                        // No moduleId, search in the whole page.\n                        scrollToText(document.body, searchText);\n                    }\n                });\n            }, 500);\n        });\n    }\n\n    /**\n     * Auto-initialize on course view pages and module pages\n     * Check if we're on a supported page and if highlight parameter exists\n     */\n    function autoInit() {\n        // Run on course view pages and specific module pages.\n        const pathname = window.location.pathname;\n        // Note: H5P (hvp, h5pactivity) is NOT supported - content is rendered in iframe.\n        const supportedPaths = [\n            '/course/view.php',\n            '/mod/page/view.php',\n            '/mod/book/view.php',\n            '/mod/lesson/view.php',\n            '/mod/wiki/view.php',\n            '/mod/forum/discuss.php',\n            '/mod/glossary/showentry.php',\n            '/mod/data/view.php'\n        ];\n        const isSupported = supportedPaths.some(function(path) {\n            return pathname.indexOf(path) !== -1;\n        });\n        if (!isSupported) {\n            return;\n        }\n\n        // Check for highlight in URL or sessionStorage.\n        const urlParams = new URLSearchParams(window.location.search);\n        let highlightText = urlParams.get('highlight');\n\n        if (!highlightText && typeof sessionStorage !== 'undefined') {\n            const storedHighlight = sessionStorage.getItem('coursesearch_highlight');\n            if (storedHighlight) {\n                // The value may be JSON-encoded.\n                try {\n                    highlightText = JSON.parse(storedHighlight);\n                    if (typeof highlightText !== 'string') {\n                        highlightText = null;\n                    }\n                } catch (e) {\n                    // If JSON parsing fails, try using it directly.\n                    highlightText = storedHighlight;\n                }\n            }\n        }\n\n        if (highlightText) {\n            init();\n        }\n    }\n\n    // Auto-initialize if highlight parameter is present.\n    // This allows the script to run even if not explicitly called.\n    if (document.readyState === 'loading') {\n        document.addEventListener('DOMContentLoaded', function() {\n            setTimeout(autoInit, 500);\n        });\n    } else {\n        // Page already loaded, run immediately.\n        setTimeout(autoInit, 500);\n    }\n\n    return {\n        init: init\n    };\n});\n"],"names":["define","$","hasHighlighted","getVisibleTextNodes","element","walker","document","createTreeWalker","NodeFilter","SHOW_TEXT","acceptNode","node","textContent","trim","el","boundary","parent","classList","style","window","getComputedStyle","contains","display","visibility","position","clip","parentElement","isElementHidden","FILTER_REJECT","FILTER_ACCEPT","textNodes","nextNode","push","applyHighlight","originalBg","backgroundColor","setProperty","setTimeout","removeProperty","findHighlightParent","validTags","body","tagName","toUpperCase","includes","documentElement","scrollToText","searchText","searchLower","toLowerCase","normalizedSearch","replace","combinedText","i","length","combinedIndex","indexOf","foundNodeIndex","firstWord","split","charCount","nodePositions","normalizedNode","nodeIndex","start","end","text","np","blockTags","rect","getBoundingClientRect","scrollY","top","scrollTo","behavior","range","createRange","textNode","originalIndex","setStart","setEnd","span","createElement","className","highlighted","startContainer","endContainer","nodeType","Node","TEXT_NODE","surroundContents","parentNode","spanParent","replaceChild","createTextNode","normalize","e","elementTop","init","highlightText","URLSearchParams","location","search","get","storedModuleId","sessionStorage","storedHighlight","getItem","timestamp","Date","now","parseInt","removeItem","JSON","parse","decodeURIComponent","ready","Promise","resolve","collapsedSections","querySelectorAll","foundInCollapsed","triggerButton","section","sectionId","id","querySelector","one","click","collapse","expandAccordionIfNeeded","then","moduleId","hash","match","test","moduleElement","getElementById","autoInit","pathname","some","path","readyState","addEventListener"],"mappings":"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"}