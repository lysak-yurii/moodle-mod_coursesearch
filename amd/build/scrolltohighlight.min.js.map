{"version":3,"file":"scrolltohighlight.min.js","sources":["../src/scrolltohighlight.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Scroll to highlighted text in course modules\n *\n * @module     mod_coursesearch/scrolltohighlight\n * @copyright  2025\n * @license    http://www.gnu.org/licenses/gpl-3.0.html GNU GPL v3 or later\n */\n\n/* eslint-disable max-depth */\n/* eslint-disable complexity */\n/* eslint-disable promise/catch-or-return */\n/* eslint-disable promise/always-return */\n\ndefine(['jquery'], function($) {\n    'use strict';\n\n    // Flag to prevent multiple executions.\n    let hasHighlighted = false;\n\n    /**\n     * Expand Bootstrap accordion/collapse if text is found inside a collapsed section\n     * Returns a promise that resolves when accordion is expanded (or immediately if not needed)\n     * @param {string} searchText The search text to look for\n     * @return {Promise} Promise that resolves when accordion is expanded\n     */\n    function expandAccordionIfNeeded(searchText) {\n        return new Promise(function(resolve) {\n            const searchLower = searchText.toLowerCase();\n\n            // Find all collapsed sections (Bootstrap 4 uses .collapse:not(.show)).\n            const collapsedSections = document.querySelectorAll('.collapse:not(.show)');\n\n            let foundInCollapsed = null;\n            let triggerButton = null;\n\n            // Check each collapsed section for the search text.\n            for (let i = 0; i < collapsedSections.length; i++) {\n                const section = collapsedSections[i];\n                const textContent = section.textContent.toLowerCase();\n\n                if (textContent.indexOf(searchLower) !== -1) {\n                    foundInCollapsed = section;\n\n                    // Find the trigger button for this collapse.\n                    // It could be a button with data-target=\"#id\" or data-bs-target=\"#id\".\n                    const sectionId = section.id;\n                    if (sectionId) {\n                        triggerButton = document.querySelector('[data-target=\"#' + sectionId + '\"]') ||\n                                       document.querySelector('[data-bs-target=\"#' + sectionId + '\"]') ||\n                                       document.querySelector('[href=\"#' + sectionId + '\"]');\n                    }\n\n                    // Also check aria-controls.\n                    if (!triggerButton && sectionId) {\n                        triggerButton = document.querySelector('[aria-controls=\"' + sectionId + '\"]');\n                    }\n\n                    break;\n                }\n            }\n\n            if (foundInCollapsed && triggerButton) {\n                // Listen for the collapse to finish expanding.\n                $(foundInCollapsed).one('shown.bs.collapse', function() {\n                    // Small delay to ensure DOM is updated.\n                    setTimeout(resolve, 100);\n                });\n\n                // Click the trigger to expand.\n                triggerButton.click();\n\n                // Fallback timeout in case the event doesn't fire.\n                setTimeout(function() {\n                    resolve();\n                }, 1000);\n            } else if (foundInCollapsed) {\n                // No trigger found, try to expand using Bootstrap's collapse API directly.\n                $(foundInCollapsed).collapse('show');\n\n                $(foundInCollapsed).one('shown.bs.collapse', function() {\n                    setTimeout(resolve, 100);\n                });\n\n                // Fallback timeout.\n                setTimeout(function() {\n                    resolve();\n                }, 1000);\n            } else {\n                // Text not in collapsed section, resolve immediately.\n                resolve();\n            }\n        });\n    }\n\n    /**\n     * Check if element is hidden\n     * @param {HTMLElement} el Element to check\n     * @param {HTMLElement} boundary Boundary element\n     * @return {boolean} True if hidden\n     */\n    function isElementHidden(el, boundary) {\n        let parent = el;\n        while (parent && parent !== boundary) {\n            const classList = parent.classList;\n            const style = window.getComputedStyle(parent);\n            // Skip screen-reader only elements and hidden elements.\n            if (classList.contains('sr-only') ||\n                classList.contains('visually-hidden') ||\n                classList.contains('hidden') ||\n                style.display === 'none' ||\n                style.visibility === 'hidden' ||\n                (style.position === 'absolute' && style.clip === 'rect(0px, 0px, 0px, 0px)')) {\n                return true;\n            }\n            parent = parent.parentElement;\n        }\n        return false;\n    }\n\n    /**\n     * Get all visible text nodes within element\n     * @param {HTMLElement} element Element to search\n     * @return {Array} Array of text nodes\n     */\n    function getVisibleTextNodes(element) {\n        const walker = document.createTreeWalker(\n            element,\n            NodeFilter.SHOW_TEXT,\n            {\n                acceptNode: function(node) {\n                    // Skip empty text nodes.\n                    if (!node.textContent.trim()) {\n                        return NodeFilter.FILTER_REJECT;\n                    }\n                    // Skip nodes inside hidden elements.\n                    if (isElementHidden(node.parentElement, element)) {\n                        return NodeFilter.FILTER_REJECT;\n                    }\n                    return NodeFilter.FILTER_ACCEPT;\n                }\n            },\n            false\n        );\n\n        let node;\n        const textNodes = [];\n        while ((node = walker.nextNode()) !== null) {\n            textNodes.push(node);\n        }\n        return textNodes;\n    }\n\n    /**\n     * Apply temporary highlight to element\n     * @param {HTMLElement} el Element to highlight\n     */\n    function applyHighlight(el) {\n        const originalBg = el.style.backgroundColor;\n        el.style.setProperty('background-color', '#ffff99', 'important');\n        setTimeout(function() {\n            if (originalBg) {\n                el.style.setProperty('background-color', originalBg);\n            } else {\n                el.style.removeProperty('background-color');\n            }\n        }, 3000);\n    }\n\n    /**\n     * Find suitable parent element for highlighting\n     * @param {Node} node Starting node\n     * @param {HTMLElement} boundary Boundary element\n     * @param {Array} validTags Valid tag names\n     * @return {HTMLElement|null} Parent element or null\n     */\n    function findHighlightParent(node, boundary, validTags) {\n        let parent = node.parentElement;\n        while (parent && parent !== boundary && parent !== document.body) {\n            const tagName = parent.tagName.toUpperCase();\n            if (validTags.includes(tagName)) {\n                break;\n            }\n            parent = parent.parentElement;\n        }\n        if (parent && parent !== boundary && parent !== document.body && parent !== document.documentElement) {\n            return parent;\n        }\n        return null;\n    }\n\n    /**\n     * Find text within an element and scroll to it\n     * @param {HTMLElement} element The element to search within\n     * @param {string} searchText The text to search for\n     * @return {boolean} True if text was found and scrolled to\n     */\n    function scrollToText(element, searchText) {\n        if (!element || !searchText) {\n            return false;\n        }\n\n        const textNodes = getVisibleTextNodes(element);\n        const searchLower = searchText.toLowerCase();\n        const normalizedSearch = searchLower.replace(/[\\u00A0\\s]+/g, ' ');\n\n        // Build combined text from all nodes.\n        let combinedText = '';\n        for (let i = 0; i < textNodes.length; i++) {\n            combinedText += textNodes[i].textContent;\n        }\n        const normalizedCombined = combinedText.replace(/[\\u00A0\\s]+/g, ' ').toLowerCase();\n        const combinedIndex = normalizedCombined.indexOf(normalizedSearch);\n\n        if (combinedIndex !== -1) {\n            let foundNodeIndex = -1;\n\n            // First, try to find exact match in a single text node.\n            for (let i = 0; i < textNodes.length; i++) {\n                const nodeText = textNodes[i].textContent;\n                const nodeTextLower = nodeText.replace(/[\\u00A0\\s]+/g, ' ').toLowerCase();\n                if (nodeTextLower.indexOf(normalizedSearch) !== -1) {\n                    foundNodeIndex = i;\n                    break;\n                }\n            }\n\n            // If no exact match in single node, find the node that contains the START of the match.\n            if (foundNodeIndex === -1) {\n                const firstWord = normalizedSearch.split(' ')[0];\n                let charCount = 0;\n                const nodePositions = [];\n                for (let i = 0; i < textNodes.length; i++) {\n                    const nodeText = textNodes[i].textContent;\n                    const normalizedNode = nodeText.replace(/[\\u00A0\\s]+/g, ' ').toLowerCase();\n                    nodePositions.push({\n                        nodeIndex: i,\n                        start: charCount,\n                        end: charCount + normalizedNode.length,\n                        text: normalizedNode\n                    });\n                    charCount += normalizedNode.length;\n                }\n\n                // Try to find a node containing the first word at the right position.\n                for (let i = 0; i < nodePositions.length; i++) {\n                    const np = nodePositions[i];\n                    if (np.end > combinedIndex && np.start <= combinedIndex + normalizedSearch.length) {\n                        if (np.text.indexOf(firstWord) !== -1) {\n                            foundNodeIndex = i;\n                            break;\n                        }\n                    }\n                }\n\n                // Fallback: find which node contains position combinedIndex.\n                if (foundNodeIndex === -1) {\n                    for (let i = 0; i < nodePositions.length; i++) {\n                        if (combinedIndex >= nodePositions[i].start && combinedIndex < nodePositions[i].end) {\n                            foundNodeIndex = i;\n                            break;\n                        }\n                    }\n                }\n            }\n\n            if (foundNodeIndex !== -1) {\n                const blockTags = ['P', 'DIV', 'LI', 'TD', 'TH', 'BLOCKQUOTE', 'ARTICLE', 'SECTION'];\n                const parent = findHighlightParent(textNodes[foundNodeIndex], element, blockTags);\n                if (parent) {\n                    const rect = parent.getBoundingClientRect();\n                    const scrollY = window.scrollY + rect.top - 100;\n                    window.scrollTo({top: scrollY, behavior: 'smooth'});\n                    applyHighlight(parent);\n                    return true;\n                }\n            }\n        }\n\n        // Original single-node search.\n        for (let i = 0; i < textNodes.length; i++) {\n            const text = textNodes[i].textContent.toLowerCase();\n            const index = text.indexOf(searchLower);\n            if (index !== -1) {\n                const range = document.createRange();\n                const textNode = textNodes[i];\n                const originalText = textNode.textContent;\n                const originalIndex = originalText.toLowerCase().indexOf(searchLower);\n\n                if (originalIndex !== -1) {\n                    try {\n                        range.setStart(textNode, originalIndex);\n                        range.setEnd(textNode, originalIndex + searchText.length);\n                        const rect = range.getBoundingClientRect();\n                        const scrollY = window.scrollY + rect.top - 100;\n                        window.scrollTo({top: scrollY, behavior: 'smooth'});\n\n                        // Highlight the text temporarily.\n                        const span = document.createElement('span');\n                        span.style.setProperty('background-color', '#ffff99', 'important');\n                        span.style.setProperty('padding', '2px', 'important');\n                        span.style.setProperty('border-radius', '2px', 'important');\n                        span.style.setProperty('color', 'inherit', 'important');\n                        span.style.setProperty('display', 'inline', 'important');\n                        span.className = 'coursesearch-highlight-temp';\n\n                        let highlighted = false;\n                        try {\n                            const canSurround = range.startContainer === range.endContainer ||\n                                (range.startContainer.nodeType === Node.TEXT_NODE &&\n                                 range.endContainer.nodeType === Node.TEXT_NODE);\n\n                            if (canSurround) {\n                                range.surroundContents(span);\n                                highlighted = true;\n                                setTimeout(function() {\n                                    if (span.parentNode) {\n                                        const spanParent = span.parentNode;\n                                        spanParent.replaceChild(document.createTextNode(span.textContent), span);\n                                        spanParent.normalize();\n                                    }\n                                }, 3000);\n                            }\n                        } catch (e) {\n                            highlighted = false;\n                        }\n\n                        // Fallback: highlight the parent element if direct highlighting failed.\n                        if (!highlighted) {\n                            const inlineTags = ['P', 'DIV', 'SPAN', 'A', 'LI', 'TD', 'TH', 'LABEL',\n                                     'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'STRONG', 'EM', 'B', 'I', 'U'];\n                            const parent = findHighlightParent(textNode, element, inlineTags);\n                            if (parent) {\n                                applyHighlight(parent);\n                            }\n                        }\n\n                        return true;\n                    } catch (e) {\n                        // If range operations fail, just scroll to the element.\n                        const elementTop = element.getBoundingClientRect().top + window.scrollY;\n                        window.scrollTo({top: elementTop - 100, behavior: 'smooth'});\n                        return true;\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Find all occurrences of search text and return array of text nodes with their positions\n     * @param {HTMLElement} element The element to search within\n     * @param {string} searchText The text to search for\n     * @return {Array} Array of objects with textNode, startIndex, and parent element\n     */\n    function findAllOccurrences(element, searchText) {\n        if (!element || !searchText) {\n            return [];\n        }\n\n        const textNodes = getVisibleTextNodes(element);\n        const searchLower = searchText.toLowerCase();\n        const normalizedSearch = searchLower.replace(/[\\u00A0\\s]+/g, ' ');\n        const occurrences = [];\n\n        for (let i = 0; i < textNodes.length; i++) {\n            const nodeText = textNodes[i].textContent;\n            const nodeTextLower = nodeText.replace(/[\\u00A0\\s]+/g, ' ').toLowerCase();\n            let startPos = 0;\n\n            // Find all occurrences within this text node.\n            let index = nodeTextLower.indexOf(normalizedSearch, startPos);\n            while (index !== -1) {\n                // Find the actual index in the original text (accounting for space normalization).\n                const originalIndex = findOriginalIndex(nodeText, nodeTextLower, index);\n\n                occurrences.push({\n                    textNode: textNodes[i],\n                    startIndex: originalIndex,\n                    length: searchText.length,\n                    nodeIndex: i\n                });\n\n                startPos = index + normalizedSearch.length;\n                index = nodeTextLower.indexOf(normalizedSearch, startPos);\n            }\n        }\n\n        return occurrences;\n    }\n\n    /**\n     * Find the original index in the text accounting for space normalization\n     * @param {string} original The original text\n     * @param {string} normalized The normalized text (spaces collapsed)\n     * @param {number} normalizedIndex Index in the normalized text\n     * @return {number} Index in the original text\n     */\n    function findOriginalIndex(original, normalized, normalizedIndex) {\n        // Simple case: if no difference in length, return same index.\n        if (original.length === normalized.length) {\n            return normalizedIndex;\n        }\n\n        // Map from normalized position to original position.\n        let normalizedPos = 0;\n        let originalPos = 0;\n        const originalLower = original.toLowerCase();\n\n        while (normalizedPos < normalizedIndex && originalPos < original.length) {\n            // Check if we're at whitespace.\n            if (/[\\u00A0\\s]/.test(originalLower[originalPos])) {\n                // Skip consecutive whitespace in original.\n                while (originalPos < original.length - 1 && /[\\u00A0\\s]/.test(originalLower[originalPos + 1])) {\n                    originalPos++;\n                }\n            }\n            originalPos++;\n            normalizedPos++;\n        }\n\n        return originalPos;\n    }\n\n    /**\n     * Remove all highlight spans from page\n     * @param {Array} highlightedElements Array of highlight span elements\n     */\n    function removeAllHighlights(highlightedElements) {\n        highlightedElements.forEach(function(span) {\n            if (span && span.parentNode) {\n                const parent = span.parentNode;\n                parent.replaceChild(document.createTextNode(span.textContent), span);\n                parent.normalize();\n            }\n        });\n    }\n\n    /**\n     * Highlight all occurrences of search text\n     * Highlights persist until user clicks somewhere on the page\n     * @param {HTMLElement} element The element to search within\n     * @param {string} searchText The text to highlight\n     * @return {boolean} True if any occurrences were highlighted\n     */\n    function highlightAllOccurrences(element, searchText) {\n        const occurrences = findAllOccurrences(element, searchText);\n\n        if (occurrences.length === 0) {\n            return false;\n        }\n\n        // Highlight each occurrence (process in reverse to avoid index shifting).\n        const highlightedElements = [];\n        for (let i = occurrences.length - 1; i >= 0; i--) {\n            const occ = occurrences[i];\n            const highlighted = highlightOccurrence(occ.textNode, occ.startIndex, searchText.length);\n            if (highlighted) {\n                highlightedElements.unshift(highlighted);\n            }\n        }\n\n        // Scroll to the first highlighted element.\n        if (highlightedElements.length > 0) {\n            const firstHighlight = highlightedElements[0];\n            const rect = firstHighlight.getBoundingClientRect();\n            const scrollY = window.scrollY + rect.top - 100;\n            window.scrollTo({top: scrollY, behavior: 'smooth'});\n\n            // Remove highlights when user clicks anywhere on the page.\n            const clickHandler = function() {\n                removeAllHighlights(highlightedElements);\n                document.removeEventListener('click', clickHandler);\n            };\n\n            // Add click listener with a small delay to avoid immediate trigger.\n            setTimeout(function() {\n                document.addEventListener('click', clickHandler);\n            }, 100);\n        }\n\n        return highlightedElements.length > 0;\n    }\n\n    /**\n     * Highlight a specific occurrence (by index) of search text\n     * @param {HTMLElement} element The element to search within\n     * @param {string} searchText The text to highlight\n     * @param {number} occurrenceIndex Which occurrence to highlight (0-indexed)\n     * @return {boolean} True if the occurrence was highlighted\n     */\n    function highlightNthOccurrence(element, searchText, occurrenceIndex) {\n        const occurrences = findAllOccurrences(element, searchText);\n\n        if (occurrences.length === 0) {\n            return false;\n        }\n\n        // Clamp occurrence index to valid range (don't exceed available occurrences).\n        if (occurrenceIndex < 0 || occurrenceIndex >= occurrences.length) {\n            occurrenceIndex = Math.min(occurrenceIndex, occurrences.length - 1);\n            if (occurrenceIndex < 0) {\n                occurrenceIndex = 0;\n            }\n        }\n\n        const occ = occurrences[occurrenceIndex];\n        const highlighted = highlightOccurrence(occ.textNode, occ.startIndex, searchText.length);\n\n        if (highlighted) {\n            const rect = highlighted.getBoundingClientRect();\n            const scrollY = window.scrollY + rect.top - 100;\n            window.scrollTo({top: scrollY, behavior: 'smooth'});\n\n            // Remove highlight after delay.\n            setTimeout(function() {\n                if (highlighted.parentNode) {\n                    const parent = highlighted.parentNode;\n                    parent.replaceChild(document.createTextNode(highlighted.textContent), highlighted);\n                    parent.normalize();\n                }\n            }, 3000);\n\n            return true;\n        }\n\n        // Even if highlighting failed, return true if we found occurrences\n        // to prevent the fallback from running and causing double-highlight.\n        // The text exists, we just couldn't visually highlight it.\n        return occurrences.length > 0;\n    }\n\n    /**\n     * Create a highlight span around text in a text node\n     * @param {Node} textNode The text node containing the text\n     * @param {number} startIndex Start index within the text node\n     * @param {number} length Length of text to highlight\n     * @return {HTMLElement|null} The highlight span element or null if failed\n     */\n    function highlightOccurrence(textNode, startIndex, length) {\n        try {\n            const text = textNode.textContent;\n\n            // Validate indices.\n            if (startIndex < 0 || startIndex >= text.length) {\n                return null;\n            }\n\n            const endIndex = Math.min(startIndex + length, text.length);\n\n            const range = document.createRange();\n            range.setStart(textNode, startIndex);\n            range.setEnd(textNode, endIndex);\n\n            const span = document.createElement('span');\n            span.style.setProperty('background-color', '#ffff99', 'important');\n            span.style.setProperty('padding', '2px', 'important');\n            span.style.setProperty('border-radius', '2px', 'important');\n            span.style.setProperty('color', 'inherit', 'important');\n            span.style.setProperty('display', 'inline', 'important');\n            span.className = 'coursesearch-highlight-temp';\n\n            range.surroundContents(span);\n            return span;\n        } catch (e) {\n            // Range operations can fail in some edge cases.\n            return null;\n        }\n    }\n\n    /**\n     * Initialize scrolling to highlighted text\n     */\n    function init() {\n        // Prevent multiple executions.\n        if (hasHighlighted) {\n            return;\n        }\n\n        // Check for cs_highlight parameter in URL.\n        // Use cs_highlight (not highlight) to avoid conflict with Moodle core's built-in highlighting.\n        const urlParams = new URLSearchParams(window.location.search);\n        let highlightText = urlParams.get('cs_highlight');\n        let highlightAll = urlParams.get('cs_highlight_all') === '1';\n        let occurrenceIndex = parseInt(urlParams.get('cs_occurrence') || '0', 10);\n\n        // If not in URL, check sessionStorage (set by coursesearch module).\n        let storedModuleId = null;\n        if (!highlightText && typeof sessionStorage !== 'undefined') {\n            const storedHighlight = sessionStorage.getItem('coursesearch_highlight');\n            storedModuleId = sessionStorage.getItem('coursesearch_moduleId');\n            const timestamp = sessionStorage.getItem('coursesearch_timestamp');\n            const storedHighlightAll = sessionStorage.getItem('coursesearch_highlight_all');\n            const storedOccurrence = sessionStorage.getItem('coursesearch_occurrence');\n\n            // Check if timestamp is recent (within 10 seconds).\n            if (timestamp && Date.now() - parseInt(timestamp, 10) > 10000) {\n                // Data is too old, clear it.\n                sessionStorage.removeItem('coursesearch_highlight');\n                sessionStorage.removeItem('coursesearch_moduleId');\n                sessionStorage.removeItem('coursesearch_timestamp');\n                sessionStorage.removeItem('coursesearch_shouldScroll');\n                sessionStorage.removeItem('coursesearch_highlight_all');\n                sessionStorage.removeItem('coursesearch_occurrence');\n                return;\n            }\n\n            if (storedHighlight) {\n                // The value was stored using JSON.stringify, so parse it back safely.\n                try {\n                    highlightText = JSON.parse(storedHighlight);\n                    if (typeof highlightText !== 'string') {\n                        highlightText = null;\n                    }\n                } catch (e) {\n                    // If JSON parsing fails, try using it directly (backwards compatibility).\n                    highlightText = storedHighlight;\n                }\n\n                // Get highlight_all and occurrence from sessionStorage.\n                highlightAll = storedHighlightAll === 'true';\n                if (storedOccurrence && /^\\d+$/.test(storedOccurrence)) {\n                    occurrenceIndex = parseInt(storedOccurrence, 10);\n                }\n\n                // Clear it after use.\n                sessionStorage.removeItem('coursesearch_highlight');\n                sessionStorage.removeItem('coursesearch_moduleId');\n                sessionStorage.removeItem('coursesearch_timestamp');\n                sessionStorage.removeItem('coursesearch_shouldScroll');\n                sessionStorage.removeItem('coursesearch_highlight_all');\n                sessionStorage.removeItem('coursesearch_occurrence');\n            }\n        }\n\n        if (!highlightText) {\n            return;\n        }\n\n        // Mark as highlighted to prevent re-runs.\n        hasHighlighted = true;\n\n        // Decode the text.\n        const searchText = decodeURIComponent(highlightText).trim();\n        if (!searchText) {\n            return;\n        }\n\n        // Wait for page to be fully loaded.\n        $(document).ready(function() {\n            // Small delay to ensure all content is rendered.\n            setTimeout(function() {\n                // First, expand any accordion that contains the search text.\n                expandAccordionIfNeeded(searchText).then(function() {\n                    // Check if we have a moduleId from sessionStorage first, then URL hash.\n                    let moduleId = storedModuleId;\n                    const hash = window.location.hash;\n\n                    if (!moduleId && hash) {\n                        // Extract module ID from hash (format: #module-123).\n                        const match = hash.match(/^#module-(\\d+)$/);\n                        if (match) {\n                            moduleId = match[1];\n                        }\n                    }\n\n                    // Validate moduleId is numeric only.\n                    if (moduleId && !/^\\d+$/.test(moduleId)) {\n                        moduleId = null;\n                    }\n\n                    // Determine the search context element.\n                    let searchElement = document.body;\n                    if (moduleId) {\n                        const moduleElement = document.getElementById('module-' + moduleId);\n                        if (moduleElement) {\n                            searchElement = moduleElement;\n                        }\n                    }\n\n                    // Apply the appropriate highlighting mode.\n                    let success = false;\n                    if (highlightAll) {\n                        // Highlight all occurrences.\n                        success = highlightAllOccurrences(searchElement, searchText);\n                        // If not found in module, try whole page.\n                        if (!success && searchElement !== document.body) {\n                            success = highlightAllOccurrences(document.body, searchText);\n                        }\n                    } else {\n                        // Highlight specific occurrence.\n                        success = highlightNthOccurrence(searchElement, searchText, occurrenceIndex);\n                        // If not found in module, try whole page.\n                        if (!success && searchElement !== document.body) {\n                            success = highlightNthOccurrence(document.body, searchText, occurrenceIndex);\n                        }\n                    }\n\n                    // Fallback to original scrollToText if new methods fail.\n                    if (!success) {\n                        if (moduleId) {\n                            const moduleElement = document.getElementById('module-' + moduleId);\n                            if (moduleElement) {\n                                if (!scrollToText(moduleElement, searchText)) {\n                                    if (!scrollToText(document.body, searchText)) {\n                                        const elementTop = moduleElement.getBoundingClientRect().top + window.scrollY;\n                                        window.scrollTo({top: elementTop - 100, behavior: 'smooth'});\n                                    }\n                                }\n                            } else {\n                                scrollToText(document.body, searchText);\n                            }\n                        } else {\n                            scrollToText(document.body, searchText);\n                        }\n                    }\n                });\n            }, 500);\n        });\n    }\n\n    /**\n     * Auto-initialize on course view pages and module pages\n     * Check if we're on a supported page and if highlight parameter exists\n     */\n    function autoInit() {\n        // Run on course view pages and specific module pages.\n        const pathname = window.location.pathname;\n        // Note: H5P (hvp, h5pactivity) is NOT supported - content is rendered in iframe.\n        const supportedPaths = [\n            '/course/view.php',\n            '/mod/page/view.php',\n            '/mod/book/view.php',\n            '/mod/lesson/view.php',\n            '/mod/wiki/view.php',\n            '/mod/forum/discuss.php',\n            '/mod/glossary/showentry.php',\n            '/mod/data/view.php'\n        ];\n        const isSupported = supportedPaths.some(function(path) {\n            return pathname.indexOf(path) !== -1;\n        });\n        if (!isSupported) {\n            return;\n        }\n\n        // Check for cs_highlight in URL or sessionStorage.\n        const urlParams = new URLSearchParams(window.location.search);\n        let highlightText = urlParams.get('cs_highlight');\n\n        if (!highlightText && typeof sessionStorage !== 'undefined') {\n            const storedHighlight = sessionStorage.getItem('coursesearch_highlight');\n            if (storedHighlight) {\n                // The value may be JSON-encoded.\n                try {\n                    highlightText = JSON.parse(storedHighlight);\n                    if (typeof highlightText !== 'string') {\n                        highlightText = null;\n                    }\n                } catch (e) {\n                    // If JSON parsing fails, try using it directly.\n                    highlightText = storedHighlight;\n                }\n            }\n        }\n\n        if (highlightText) {\n            init();\n        }\n    }\n\n    // Auto-initialize if highlight parameter is present.\n    // This allows the script to run even if not explicitly called.\n    if (document.readyState === 'loading') {\n        document.addEventListener('DOMContentLoaded', function() {\n            setTimeout(autoInit, 500);\n        });\n    } else {\n        // Page already loaded, run immediately.\n        setTimeout(autoInit, 500);\n    }\n\n    return {\n        init: init\n    };\n});\n"],"names":["define","$","hasHighlighted","getVisibleTextNodes","element","walker","document","createTreeWalker","NodeFilter","SHOW_TEXT","acceptNode","node","textContent","trim","el","boundary","parent","classList","style","window","getComputedStyle","contains","display","visibility","position","clip","parentElement","isElementHidden","FILTER_REJECT","FILTER_ACCEPT","textNodes","nextNode","push","applyHighlight","originalBg","backgroundColor","setProperty","setTimeout","removeProperty","findHighlightParent","validTags","body","tagName","toUpperCase","includes","documentElement","scrollToText","searchText","searchLower","toLowerCase","normalizedSearch","replace","combinedText","i","length","combinedIndex","indexOf","foundNodeIndex","firstWord","split","charCount","nodePositions","normalizedNode","nodeIndex","start","end","text","np","blockTags","rect","getBoundingClientRect","scrollY","top","scrollTo","behavior","range","createRange","textNode","originalIndex","setStart","setEnd","span","createElement","className","highlighted","startContainer","endContainer","nodeType","Node","TEXT_NODE","surroundContents","parentNode","spanParent","replaceChild","createTextNode","normalize","e","elementTop","findAllOccurrences","occurrences","nodeText","nodeTextLower","startPos","index","findOriginalIndex","startIndex","original","normalized","normalizedIndex","normalizedPos","originalPos","originalLower","test","highlightAllOccurrences","highlightedElements","occ","highlightOccurrence","unshift","clickHandler","forEach","removeAllHighlights","removeEventListener","addEventListener","highlightNthOccurrence","occurrenceIndex","Math","min","endIndex","init","urlParams","URLSearchParams","location","search","highlightText","get","highlightAll","parseInt","storedModuleId","sessionStorage","storedHighlight","getItem","timestamp","storedHighlightAll","storedOccurrence","Date","now","removeItem","JSON","parse","decodeURIComponent","ready","Promise","resolve","collapsedSections","querySelectorAll","foundInCollapsed","triggerButton","section","sectionId","id","querySelector","one","click","collapse","expandAccordionIfNeeded","then","moduleId","hash","match","searchElement","moduleElement","getElementById","success","autoInit","pathname","some","path","readyState"],"mappings":"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"}